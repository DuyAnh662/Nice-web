<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HYPER CORE - C·ª±c Quang ƒêi·ªÅu Khi·ªÉn B·∫±ng Tay</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(45deg, #000000, #0a0a2a, #000000);
            font-family: 'Orbitron', sans-serif;
            color: #fff;
            height: 100vh;
            width: 100vw;
        }

        /* Container ch√≠nh */
        #universe {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #canvas3d {
            z-index: 2;
            pointer-events: none;
        }

        /* HUD Interface */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        /* Loading Screen */
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00f3ff;
            font-size: 24px;
            z-index: 100;
            text-align: center;
            background: rgba(0, 10, 20, 0.9);
            padding: 30px 50px;
            border-radius: 15px;
            border: 2px solid #00f3ff;
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .loading-bar {
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            margin: 20px auto;
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-progress {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00f3ff, #ff00ff);
            transition: width 0.3s ease;
        }

        /* Webcam HUD */
        #camera-hud {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 11;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 15px;
        }

        .cam-container {
            position: relative;
            width: 220px;
            height: 165px;
            border: 3px solid;
            border-image: linear-gradient(45deg, #00f3ff, #ff00ff) 1;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.4);
            backdrop-filter: blur(5px);
            transform: scaleX(-1);
        }

        .cam-feed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .cam-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, 
                rgba(0, 243, 255, 0.1), 
                rgba(255, 0, 255, 0.1));
            mix-blend-mode: screen;
        }

        /* Controls Panel */
        .controls-panel {
            background: rgba(0, 20, 40, 0.85);
            border: 2px solid rgba(0, 243, 255, 0.5);
            border-radius: 15px;
            padding: 20px;
            width: 280px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 40px rgba(0, 243, 255, 0.2);
        }

        .control-item {
            display: flex;
            align-items: center;
            margin: 12px 0;
            color: #fff;
            font-size: 14px;
        }

        .control-icon {
            width: 40px;
            height: 40px;
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            font-size: 20px;
        }

        .control-text {
            flex: 1;
        }

        .control-text b {
            color: #00f3ff;
            display: block;
            font-size: 16px;
            margin-bottom: 4px;
        }

        /* Title */
        .title {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 9;
        }

        .main-title {
            font-size: 3.5em;
            background: linear-gradient(45deg, #00f3ff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 243, 255, 0.5);
            margin-bottom: 10px;
            letter-spacing: 3px;
        }

        .subtitle {
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.7);
            letter-spacing: 2px;
        }

        /* Stats */
        .stats {
            position: fixed;
            bottom: 30px;
            left: 30px;
            background: rgba(0, 20, 40, 0.8);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(0, 243, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 14px;
        }

        .stat-value {
            color: #00f3ff;
            font-weight: bold;
        }

        /* Effects Overlay */
        #effects-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none;
            mix-blend-mode: screen;
        }

        /* Mobile Optimizations */
        @media (max-width: 768px) {
            .title {
                top: 20px;
            }
            
            .main-title {
                font-size: 2em;
            }
            
            .cam-container {
                width: 150px;
                height: 200px;
            }
            
            .controls-panel {
                width: 220px;
                padding: 15px;
            }
            
            .stats {
                left: 20px;
                right: 20px;
                bottom: 250px;
            }
        }

        /* Animations */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        @keyframes glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.5); }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .pulse { animation: pulse 2s infinite; }
        .glow { animation: glow 3s infinite; }
        .float { animation: float 4s ease-in-out infinite; }
    </style>
</head>

<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="float">‚ö°</div>
        <div>KH·ªûI T·∫†O SI√äU L√ïI NƒÇNG L∆Ø·ª¢NG</div>
        <div class="loading-bar">
            <div class="loading-progress" id="loading-progress"></div>
        </div>
        <div id="loading-text" style="font-size: 14px; margin-top: 10px;">
            ƒêang k·∫øt n·ªëi v·ªõi h·ªá th·ªëng l∆∞·ª£ng t·ª≠...
        </div>
    </div>

    <!-- Main Universe -->
    <div id="universe">
        <canvas id="background"></canvas>
        <canvas id="canvas3d"></canvas>
        <div id="effects-overlay"></div>
    </div>

    <!-- Title -->
    <div class="title">
        <div class="main-title glow">HYPER CORE</div>
        <div class="subtitle">ƒêI·ªÄU KHI·ªÇN B·∫∞NG C·ª¨ CH·ªà TAY</div>
    </div>

    <!-- Stats Panel -->
    <div class="stats">
        <div class="stat-item">
            <span>NƒÇNG L∆Ø·ª¢NG:</span>
            <span class="stat-value" id="energy-level">92.7%</span>
        </div>
        <div class="stat-item">
            <span>ƒê·ªò ·ªîN ƒê·ªäNH:</span>
            <span class="stat-value" id="stability">85.4%</span>
        </div>
        <div class="stat-item">
            <span>T·∫¶N S·ªê:</span>
            <span class="stat-value" id="frequency">147.8GHz</span>
        </div>
        <div class="stat-item">
            <span>NHI·ªÜT ƒê·ªò L√ïI:</span>
            <span class="stat-value" id="temperature">8,472K</span>
        </div>
    </div>

    <!-- Camera HUD -->
    <div id="camera-hud">
        <div class="controls-panel">
            <div class="control-item">
                <div class="control-icon">üñê</div>
                <div class="control-text">
                    <b>PH√ìNG TO</b>
                    M·ªü b√†n tay ho√†n to√†n
                </div>
            </div>
            <div class="control-item">
                <div class="control-icon">‚úä</div>
                <div class="control-text">
                    <b>THU NH·ªé</b>
                    N·∫Øm ch·∫∑t tay l·∫°i
                </div>
            </div>
            <div class="control-item">
                <div class="control-icon">üëÜ</div>
                <div class="control-text">
                    <b>XOAY 3D</b>
                    Di chuy·ªÉn b√†n tay
                </div>
            </div>
            <div class="control-item">
                <div class="control-icon">ü§ò</div>
                <div class="control-text">
                    <b>K√çCH HO·∫†T</b>
                    Ng√≥n c√°i & ng√≥n √∫t
                </div>
            </div>
        </div>
        
        <div class="cam-container pulse">
            <video class="cam-feed input_video" playsinline webkit-playsinline muted autoplay></video>
            <canvas class="cam-feed output_canvas"></canvas>
            <div class="cam-overlay"></div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>

    <script>
        // ==================== INITIALIZATION ====================
        const loadingDiv = document.getElementById('loading');
        const loadingProgress = document.getElementById('loading-progress');
        const loadingText = document.getElementById('loading-text');
        
        // Simulate loading progress
        const loadingStages = [
            "ƒêang kh·ªüi t·∫°o h·ªá th·ªëng l∆∞·ª£ng t·ª≠...",
            "K·∫øt n·ªëi v·ªõi tr∆∞·ªùng nƒÉng l∆∞·ª£ng...",
            "Kh·ªüi t·∫°o l√µi plasma...",
            "X√¢y d·ª±ng c·∫•u tr√∫c ƒëa chi·ªÅu...",
            "K√≠ch ho·∫°t h·ªá th·ªëng h·∫°t...",
            "S·∫µn s√†ng!"
        ];
        
        let loadProgress = 0;
        const loadInterval = setInterval(() => {
            loadProgress += 20;
            loadingProgress.style.width = `${loadProgress}%`;
            loadingText.textContent = loadingStages[loadProgress / 20];
            
            if (loadProgress >= 100) {
                clearInterval(loadInterval);
                setTimeout(() => {
                    loadingDiv.style.opacity = '0';
                    setTimeout(() => {
                        loadingDiv.style.display = 'none';
                    }, 500);
                }, 500);
            }
        }, 300);

        // ==================== THREE.JS SETUP ====================
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('canvas3d'),
            antialias: true,
            alpha: true,
            powerPreference: "high-performance"
        });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        camera.position.set(0, 2, 15);

        // ==================== ADVANCED LIGHTING ====================
        // 1. Main Directional Light
        const mainLight = new THREE.DirectionalLight(0x00f3ff, 2);
        mainLight.position.set(10, 10, 10);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);

        // 2. Ambient Light
        const ambientLight = new THREE.AmbientLight(0x000022, 0.5);
        scene.add(ambientLight);

        // 3. Point Lights Array (Create dynamic lights)
        const pointLights = [];
        const lightColors = [0x00f3ff, 0xff00ff, 0xffff00, 0x00ff88];
        
        for (let i = 0; i < 8; i++) {
            const color = lightColors[i % lightColors.length];
            const light = new THREE.PointLight(color, 1, 100);
            light.position.set(
                Math.cos(i * Math.PI / 4) * 20,
                Math.sin(i * Math.PI / 4) * 20,
                Math.cos(i * Math.PI / 3) * 20
            );
            scene.add(light);
            pointLights.push(light);
        }

        // ==================== HYPER CORE CONSTRUCTION ====================
        const coreGroup = new THREE.Group();
        scene.add(coreGroup);

        // 1. CENTRAL SUN (Ultra Detailed)
        const sunGeometry = new THREE.IcosahedronGeometry(2, 8);
        const sunMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            emissive: 0xffaa00,
            emissiveIntensity: 2,
            metalness: 0.8,
            roughness: 0.2,
            transparent: true,
            opacity: 0.95
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.castShadow = true;
        coreGroup.add(sun);

        // 2. ENERGY SPHERE (Pulsing Layer)
        const energySphereGeometry = new THREE.IcosahedronGeometry(3, 6);
        const energySphereMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                color1: { value: new THREE.Color(0x00f3ff) },
                color2: { value: new THREE.Color(0xff00ff) }
            },
            vertexShader: `
                varying vec3 vPosition;
                void main() {
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform vec3 color1;
                uniform vec3 color2;
                varying vec3 vPosition;
                
                void main() {
                    float wave = sin(vPosition.x * 2.0 + time) * 
                                sin(vPosition.y * 2.0 + time) * 
                                sin(vPosition.z * 2.0 + time) * 0.5 + 0.5;
                    
                    vec3 color = mix(color1, color2, wave);
                    float alpha = 0.1 + wave * 0.2;
                    
                    gl_FragColor = vec4(color, alpha);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
        });
        const energySphere = new THREE.Mesh(energySphereGeometry, energySphereMaterial);
        coreGroup.add(energySphere);

        // 3. RINGS SYSTEM (Multiple detailed rings)
        const rings = [];
        const ringCount = 12;
        
        for (let i = 0; i < ringCount; i++) {
            const radius = 4 + i * 1.5;
            const tube = 0.1 + i * 0.05;
            const ringGeometry = new THREE.TorusGeometry(radius, tube, 32, 200);
            const ringMaterial = new THREE.MeshPhongMaterial({
                color: i % 2 === 0 ? 0x00f3ff : 0xff00ff,
                emissive: i % 2 === 0 ? 0x002244 : 0x440022,
                transparent: true,
                opacity: 0.3 + (i * 0.05),
                side: THREE.DoubleSide,
                wireframe: i > 6
            });
            
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            ring.rotation.y = i * Math.PI / ringCount;
            
            ring.userData = {
                speed: 0.002 + (i * 0.001),
                phase: i * 0.5,
                scale: 1
            };
            
            rings.push(ring);
            coreGroup.add(ring);
        }

        // 4. ORBITAL PARTICLES (Thousands of particles)
        const particleCount = 5000;
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            const radius = 5 + Math.random() * 20;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
            positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            positions[i3 + 2] = radius * Math.cos(phi);
            
            const color = new THREE.Color();
            color.setHSL(Math.random(), 1, 0.5);
            
            colors[i3] = color.r;
            colors[i3 + 1] = color.g;
            colors[i3 + 2] = color.b;
        }
        
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.2,
            vertexColors: true,
            transparent: true,
            blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particles);

        // 5. ELECTRIC ARCS (Dynamic lightning)
        const arcsGroup = new THREE.Group();
        coreGroup.add(arcsGroup);
        
        function createArc(start, end, color = 0x00ffff) {
            const points = [];
            const segments = 20;
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const point = new THREE.Vector3().lerpVectors(start, end, t);
                
                // Add randomness for lightning effect
                if (i > 0 && i < segments) {
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5
                    );
                    point.add(offset);
                }
                
                points.push(point);
            }
            
            const curve = new THREE.CatmullRomCurve3(points);
            const geometry = new THREE.TubeGeometry(curve, segments, 0.02, 8, false);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });
            
            const arc = new THREE.Mesh(geometry, material);
            arc.userData = {
                life: 1.0,
                decay: 0.02 + Math.random() * 0.03
            };
            
            return arc;
        }

        // ==================== BACKGROUND UNIVERSE ====================
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 10000;
        const starPositions = new Float32Array(starCount * 3);
        const starSizes = new Float32Array(starCount);
        
        for (let i = 0; i < starCount * 3; i += 3) {
            starPositions[i] = (Math.random() - 0.5) * 2000;
            starPositions[i + 1] = (Math.random() - 0.5) * 2000;
            starPositions[i + 2] = (Math.random() - 0.5) * 2000;
            
            starSizes[i / 3] = Math.random() * 2;
        }
        
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
        
        const starMaterial = new THREE.PointsMaterial({
            size: 1,
            sizeAttenuation: true,
            color: 0xffffff,
            transparent: true,
            opacity: 0.8
        });
        
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Nebula Background
        const nebulaGeometry = new THREE.SphereGeometry(500, 32, 32);
        const nebulaMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 }
            },
            vertexShader: `
                varying vec3 vPosition;
                void main() {
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec3 vPosition;
                
                void main() {
                    vec3 color1 = vec3(0.0, 0.3, 0.5);
                    vec3 color2 = vec3(0.5, 0.0, 0.3);
                    
                    float noise = sin(vPosition.x * 0.01 + time * 0.1) * 
                                 cos(vPosition.y * 0.01 + time * 0.1) * 
                                 sin(vPosition.z * 0.01 + time * 0.1);
                    
                    vec3 color = mix(color1, color2, noise * 0.5 + 0.5);
                    gl_FragColor = vec4(color, 0.05);
                }
            `,
            transparent: true,
            side: THREE.BackSide
        });
        
        const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
        scene.add(nebula);

        // ==================== HAND CONTROL SYSTEM ====================
        const videoElement = document.querySelector('.input_video');
        const canvasElement = document.querySelector('.output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        
        // Control variables
        let targetScale = 1;
        let currentScale = 1;
        let targetRotation = new THREE.Vector2(0, 0);
        let currentRotation = new THREE.Vector2(0, 0);
        let handDetected = false;
        let lastGestureTime = 0;
        let energyLevel = 0.927;
        let stability = 0.854;
        
        // Initialize MediaPipe Hands
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults((results) => {
            // Update HUD canvas
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // Draw hand skeleton
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
                    color: '#00f3ff',
                    lineWidth: 2
                });
                
                drawLandmarks(canvasCtx, landmarks, {
                    color: '#ff00ff',
                    lineWidth: 1,
                    radius: 3
                });
                
                // Calculate hand metrics
                const wrist = landmarks[0];
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];
                
                // 1. ZOOM CONTROL (Distance between thumb and pinky)
                const thumbToPinky = Math.sqrt(
                    Math.pow(thumbTip.x - pinkyTip.x, 2) +
                    Math.pow(thumbTip.y - pinkyTip.y, 2)
                );
                
                targetScale = 0.5 + thumbToPinky * 3;
                targetScale = Math.max(0.3, Math.min(targetScale, 3));
                
                // 2. ROTATION CONTROL (Palm position)
                const palmBase = landmarks[9];
                const rotationX = (palmBase.y - 0.5) * 2;
                const rotationY = (palmBase.x - 0.5) * 2;
                
                targetRotation.x = rotationX * Math.PI;
                targetRotation.y = rotationY * Math.PI * 2;
                
                // 3. SPECIAL GESTURES
                const currentTime = Date.now();
                
                // Fist gesture (Close hand)
                const fistDistance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) +
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );
                
                if (fistDistance < 0.1 && currentTime - lastGestureTime > 1000) {
                    triggerSpecialEffect();
                    lastGestureTime = currentTime;
                }
                
                // Update stats
                updateStats();
                
            } else {
                handDetected = false;
                // Gentle reset when no hand
                targetScale += (1 - targetScale) * 0.05;
                targetRotation.x *= 0.95;
                targetRotation.y *= 0.95;
            }
            
            canvasCtx.restore();
        });
        
        // Camera setup
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 480,
            height: 640
        });
        
        cameraUtils.start().catch(err => {
            console.error("Camera error:", err);
            loadingText.textContent = "L·ªói camera. Vui l√≤ng ki·ªÉm tra quy·ªÅn truy c·∫≠p.";
        });
        
        // ==================== SPECIAL EFFECTS ====================
        function triggerSpecialEffect() {
            // Create energy burst
            const burstGeometry = new THREE.SphereGeometry(5, 16, 16);
            const burstMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            const burst = new THREE.Mesh(burstGeometry, burstMaterial);
            burst.position.copy(sun.position);
            scene.add(burst);
            
            // Animate burst
            gsap.to(burst.scale, {
                x: 3,
                y: 3,
                z: 3,
                duration: 0.5,
                ease: "power2.out"
            });
            
            gsap.to(burst.material, {
                opacity: 0,
                duration: 0.5,
                delay: 0.2,
                onComplete: () => scene.remove(burst)
            });
            
            // Create lightning arcs
            for (let i = 0; i < 5; i++) {
                const start = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                
                const end = new THREE.Vector3(
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20
                );
                
                const arc = createArc(start, end);
                arcsGroup.add(arc);
            }
            
            // Update stats with burst
            energyLevel = Math.min(1, energyLevel + 0.1);
            stability = Math.max(0.5, stability - 0.05);
        }
        
        function updateStats() {
            // Update energy level
            energyLevel += (Math.random() - 0.5) * 0.01;
            energyLevel = Math.max(0.5, Math.min(1, energyLevel));
            
            // Update stability based on hand detection
            if (handDetected) {
                stability += (0.9 - stability) * 0.05;
            } else {
                stability += (0.7 - stability) * 0.05;
            }
            
            // Update DOM elements
            document.getElementById('energy-level').textContent = 
                `${(energyLevel * 100).toFixed(1)}%`;
            document.getElementById('stability').textContent = 
                `${(stability * 100).toFixed(1)}%`;
            document.getElementById('frequency').textContent = 
                `${(147.8 + (Math.random() - 0.5) * 0.2).toFixed(1)}GHz`;
            document.getElementById('temperature').textContent = 
                `${(8472 + (Math.random() - 0.5) * 100).toFixed(0)}K`;
        }
        
        // ==================== ANIMATION LOOP ====================
        let time = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;
            
            // Update shader uniforms
            if (energySphere.material.uniforms) {
                energySphere.material.uniforms.time.value = time;
            }
            
            if (nebula.material.uniforms) {
                nebula.material.uniforms.time.value = time;
            }
            
            // Smooth interpolation for controls
            currentScale += (targetScale - currentScale) * 0.1;
            currentRotation.x += (targetRotation.x - currentRotation.x) * 0.1;
            currentRotation.y += (targetRotation.y - currentRotation.y) * 0.1;
            
            // Apply transformations to core group
            coreGroup.scale.setScalar(currentScale);
            coreGroup.rotation.x = currentRotation.x;
            coreGroup.rotation.y = currentRotation.y;
            
            // Animate core elements
            sun.rotation.x += 0.005;
            sun.rotation.y += 0.003;
            
            // Animate rings
            rings.forEach((ring, i) => {
                const data = ring.userData;
                ring.rotation.z += data.speed;
                ring.rotation.y = Math.sin(time * 0.5 + data.phase) * 0.2;
                
                // Pulse effect
                const pulse = Math.sin(time * 2 + i) * 0.1 + 0.9;
                ring.scale.setScalar(pulse);
            });
            
            // Animate particles
            particles.rotation.x += 0.0005;
            particles.rotation.y += 0.001;
            
            // Animate point lights
            pointLights.forEach((light, i) => {
                const angle = time * 0.5 + (i * Math.PI * 2) / pointLights.length;
                light.position.x = Math.cos(angle) * 15;
                light.position.z = Math.sin(angle) * 15;
                light.position.y = Math.sin(angle * 1.3) * 5;
                
                // Pulse intensity
                const intensity = 0.5 + Math.sin(time * 2 + i) * 0.3;
                light.intensity = intensity;
            });
            
            // Update arcs
            arcsGroup.children.forEach((arc, index) => {
                arc.userData.life -= arc.userData.decay;
                
                if (arc.userData.life <= 0) {
                    arcsGroup.remove(arc);
                } else {
                    arc.material.opacity = arc.userData.life * 0.7;
                }
            });
            
            // Create new arcs randomly
            if (Math.random() < 0.1 && arcsGroup.children.length < 20) {
                const start = new THREE.Vector3(
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8
                );
                
                const end = new THREE.Vector3(
                    (Math.random() - 0.5) * 15,
                    (Math.random() - 0.5) * 15,
                    (Math.random() - 0.5) * 15
                );
                
                const arc = createArc(start, end);
                arcsGroup.add(arc);
            }
            
            // Rotate nebula
            nebula.rotation.y += 0.0002;
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        // ==================== RESIZE HANDLER ====================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('resize', onWindowResize);
        
        // ==================== START APPLICATION ====================
        // Draw connectors and landmarks functions (from MediaPipe)
        function drawConnectors(ctx, points, connections, style) {
            ctx.strokeStyle = style.color;
            ctx.lineWidth = style.lineWidth;
            ctx.beginPath();
            
            connections.forEach(([start, end]) => {
                const startPoint = points[start];
                const endPoint = points[end];
                
                if (startPoint && endPoint) {
                    ctx.moveTo(startPoint.x * canvasElement.width, startPoint.y * canvasElement.height);
                    ctx.lineTo(endPoint.x * canvasElement.width, endPoint.y * canvasElement.height);
                }
            });
            
            ctx.stroke();
        }
        
        function drawLandmarks(ctx, points, style) {
            ctx.fillStyle = style.color;
            ctx.strokeStyle = style.color;
            ctx.lineWidth = style.lineWidth;
            
            points.forEach(point => {
                if (point) {
                    ctx.beginPath();
                    ctx.arc(
                        point.x * canvasElement.width,
                        point.y * canvasElement.height,
                        style.radius || 3,
                        0,
                        2 * Math.PI
                    );
                    ctx.fill();
                    
                    if (style.lineWidth > 0) {
                        ctx.stroke();
                    }
                }
            });
        }
        
        // Start animation
        animate();
        
        // Initial stats update
        setInterval(updateStats, 1000);
    </script>
</body>

</html>