<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Hand Control - iOS Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        
        /* Container cho 3D */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* M√†n h√¨nh ch·ªù */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffcc; font-size: 18px; z-index: 20; pointer-events: none;
            text-align: center; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;
            border: 1px solid #00ffcc;
        }

        /* --- KHU V·ª∞C HUD (Webcam Mini) --- */
        #hud-wrapper {
            position: absolute; bottom: 20px; right: 20px; z-index: 10;
            display: flex; flex-direction: column; align-items: flex-end;
            pointer-events: none; /* ƒê·ªÉ b·∫•m xuy√™n qua ƒë∆∞·ª£c n·∫øu c·∫ßn */
        }

        .cam-box {
            position: relative;
            width: 160px; height: 120px;
            border: 2px solid #00ffcc;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
            transform: scaleX(-1); /* L·∫≠t ng∆∞·ª£c g∆∞∆°ng gi·ªëng soi g∆∞∆°ng */
        }

        /* Video g·ªëc v√† Canvas v·∫Ω x∆∞∆°ng tay */
        .input_video { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; 
        }
        .output_canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
        }

        /* H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng */
        .guide-box {
            margin-bottom: 10px;
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid rgba(0, 255, 204, 0.5);
            color: #fff; padding: 10px; border-radius: 8px;
            font-size: 12px; width: 200px; text-align: right;
            backdrop-filter: blur(5px);
        }
        .guide-box b { color: #00ffcc; }
        
        /* Ch·ªâ hi·ªÉn th·ªã tr√™n mobile */
        @media (max-width: 600px) {
            .cam-box { width: 120px; height: 160px; } /* Camera d·ªçc cho ƒëi·ªán tho·∫°i */
            .guide-box { width: 150px; font-size: 11px; }
        }
    </style>
</head>
<body>

    <div id="loading">
        üöÄ ƒêang kh·ªüi ƒë·ªông h·ªá th·ªëng...<br>
        <small>Vui l√≤ng ch·ªù & Cho ph√©p Camera</small>
    </div>

    <div id="canvas-container"></div>

    <div id="hud-wrapper">
        <div class="guide-box">
            <div>üñê <b>M·ªü tay:</b> Ph√≥ng to v·∫≠t th·ªÉ</div>
            <div>‚úä <b>N·∫Øm tay:</b> Thu nh·ªè v·∫≠t th·ªÉ</div>
            <div>üëã <b>Di chuy·ªÉn:</b> Xoay camera</div>
            <div style="margin-top:5px; color:#aaa; font-style:italic;">(ƒê·∫∑t tay v√†o khung b√™n d∆∞·ªõi)</div>
        </div>
        
        <div class="cam-box">
            <video class="input_video" playsinline webkit-playsinline muted autoplay></video>
            <canvas class="output_canvas"></canvas>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- 1. SETUP THREE.JS (ƒê·ªí H·ªåA) ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000510, 0.02); // S∆∞∆°ng m√π t√≠m ƒëen

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 6;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // T·ªëi ∆∞u cho mobile
        container.appendChild(renderer.domElement);

        // √Ånh s√°ng
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const pointLight1 = new THREE.PointLight(0x00ffcc, 1.5, 50);
        pointLight1.position.set(2, 2, 5);
        scene.add(pointLight1);
        const pointLight2 = new THREE.PointLight(0xff00cc, 1.5, 50);
        pointLight2.position.set(-2, -2, 5);
        scene.add(pointLight2);

        // V·∫¨T TH·ªÇ: L√ïI C√îNG NGH·ªÜ CAO
        const group = new THREE.Group();
        scene.add(group);

        // V·ªè ngo√†i (Icosahedron)
        const outerGeo = new THREE.IcosahedronGeometry(1.2, 0);
        const outerMat = new THREE.MeshStandardMaterial({ 
            color: 0x00ffcc, wireframe: true, emissive: 0x00ffcc, emissiveIntensity: 0.2
        });
        const outerMesh = new THREE.Mesh(outerGeo, outerMat);
        group.add(outerMesh);

        // L√µi trong (Kh·ªëi ƒë·∫∑c)
        const innerGeo = new THREE.OctahedronGeometry(0.6, 0);
        const innerMat = new THREE.MeshStandardMaterial({ 
            color: 0xff00cc, roughness: 0.2, metalness: 0.8
        });
        const innerMesh = new THREE.Mesh(innerGeo, innerMat);
        group.add(innerMesh);

        // Sao n·ªÅn
        const starGeo = new THREE.BufferGeometry();
        const starCount = 800;
        const starPos = new Float32Array(starCount * 3);
        for(let i=0; i<starCount*3; i++) starPos[i] = (Math.random() - 0.5) * 60;
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.05}));
        scene.add(stars);

        // Bi·∫øn ƒëi·ªÅu khi·ªÉn
        let targetScale = 1;
        let currentScale = 1;
        let targetRotX = 0, targetRotY = 0;
        let lastX = 0.5, lastY = 0.5;

        // --- 2. SETUP MEDIAPIPE (AI CAMERA) ---
        const videoElement = document.querySelector('.input_video');
        const canvasElement = document.querySelector('.output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const loadingDiv = document.getElementById('loading');

        function onResults(results) {
            // ·∫®n loading khi ƒë√£ nh·∫≠n ƒë∆∞·ª£c frame ƒë·∫ßu ti√™n
            loadingDiv.style.display = 'none';

            // V·∫Ω l√™n canvas mini
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            // V·∫Ω ·∫£nh webcam (n·∫øu mu·ªën)
            // canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // V·∫Ω x∆∞∆°ng tay l√™n HUD mini
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00ffcc', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#ff00cc', lineWidth: 1, radius: 2});

                // LOGIC ƒêI·ªÄU KHI·ªÇN
                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                
                // ƒêo kho·∫£ng c√°ch (Zoom)
                const distance = Math.sqrt(
                    Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2)
                );
                // ƒêi·ªÅu ch·ªânh ƒë·ªô nh·∫°y zoom
                let openness = (distance - 0.1) * 5;
                if (openness < 0.3) openness = 0.3;
                if (openness > 2.0) openness = 2.0;
                targetScale = openness;

                // ƒêo v·ªã tr√≠ (Xoay)
                const palmX = landmarks[9].x;
                const palmY = landmarks[9].y;
                const sensitivity = 5; // ƒê·ªô nh·∫°y xoay
                
                // T√≠nh ƒë·ªô l·ªách xoay
                targetRotY += (palmX - lastX) * -sensitivity; 
                targetRotX += (palmY - lastY) * sensitivity;
                
                lastX = palmX;
                lastY = palmY;

            } else {
                // Kh√¥ng th·∫•y tay: Reset nh·∫π
                targetScale = 1;
                targetRotY += 0.002;
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // D√πng model nh·∫π cho mobile m∆∞·ª£t h∆°n
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        // Camera setup cho iOS
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 480, // Gi·∫£m ƒë·ªô ph√¢n gi·∫£i ch√∫t ƒë·ªÉ mobile ch·∫°y nhanh
            height: 640
        });
        
        // B·∫Øt l·ªói camera
        cameraUtils.start().catch(err => {
            loadingDiv.innerHTML = "‚ùå L·ªói Camera: " + err + "<br>H√£y th·ª≠ m·ªü b·∫±ng Safari v√† ch·ªçn HTTPS.";
        });

        // --- 3. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Lerp ƒë·ªÉ m∆∞·ª£t chuy·ªÉn ƒë·ªông
            currentScale += (targetScale - currentScale) * 0.1;
            
            group.scale.set(currentScale, currentScale, currentScale);
            group.rotation.y += (targetRotY - group.rotation.y) * 0.1;
            group.rotation.x += (targetRotX - group.rotation.x) * 0.1;

            // Hi·ªáu ·ª©ng "s·ªëng"
            outerMesh.rotation.z -= 0.01;
            outerMesh.rotation.y -= 0.005;
            innerMesh.rotation.x += 0.02;
            
            // Sao xoay theo
            stars.rotation.y = group.rotation.y * 0.2;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
