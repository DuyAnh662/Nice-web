<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Epic Hyper Core — Đồ Sộ & Hùng Vĩ</title>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@200;400;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --accent1: #00f2ff;
      --accent2: #bd00ff;
      --bg-dark: #010004;
      --glass: rgba(255,255,255,0.04);
      --hud-border: rgba(0,242,255,0.18);
      --mono: 'Outfit', system-ui, -apple-system, "Segoe UI", Roboto, 'Helvetica Neue', Arial;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#000012 0%, #000010 40%, #050019 100%);font-family:var(--mono);color:#dfefff;}

    /* Full-screen 3D canvas stack */
    #canvas-wrap{position:fixed;inset:0;overflow:hidden;}
    canvas{display:block;position:absolute;inset:0;width:100%;height:100%;}

    /* UI overlay */
    #ui{position:fixed;left:24px;top:24px;z-index:60;display:flex;flex-direction:column;gap:12px;pointer-events:none}
    .panel{pointer-events:auto;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid var(--hud-border);backdrop-filter:blur(6px);padding:12px;border-radius:10px;box-shadow:0 4px 40px rgba(0,0,0,0.6)}
    .title{font-weight:700;font-size:14px;color:var(--accent1);margin-bottom:6px}
    .controls{font-size:13px;color:#cfefff;line-height:1.3}

    /* small HUD camera */
    #hud-wrapper{position:fixed;right:20px;bottom:20px;z-index:60;display:flex;flex-direction:column;align-items:flex-end;gap:10px}
    .cam-box{width:180px;height:140px;border-radius:12px;overflow:hidden;border:1px solid var(--hud-border);background:linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.3));box-shadow:0 8px 40px rgba(0,0,0,0.6);transform:scaleX(-1)}
    .cam-box video, .cam-box canvas{width:100%;height:100%;object-fit:cover;display:block}
    .guide{width:220px;text-align:right;padding:10px;border-radius:10px;background:rgba(0,10,20,0.5);border:1px solid rgba(255,255,255,0.02);font-size:12px}

    /* Loading modal */
    #loading{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:70;background:rgba(0,0,0,0.7);padding:18px;border-radius:12px;border:1px solid var(--hud-border);font-size:14px;color:var(--accent1);pointer-events:none}

    /* Interaction hints (hidden on small screens) */
    @media (max-width:600px){
      .cam-box{width:140px;height:180px}
      #ui{left:12px;top:12px}
      .guide{width:160px;font-size:11px}
    }
  </style>
</head>

<body>
  <div id="canvas-wrap">
    <canvas id="bg-canvas"></canvas> <!-- particles, fog sprites -->
    <canvas id="main-canvas"></canvas> <!-- three.js main scene -->
    <canvas id="post-canvas"></canvas> <!-- bloom + glare approximations -->
  </div>

  <div id="loading">Khởi tạo hệ thống — Cho phép Camera để điều khiển</div>

  <div id="ui">
    <div class="panel">
      <div class="title">Hệ thống: HYPER CORE — Epic Edition</div>
      <div class="controls">
        • Mở tay / Nắm tay: Phóng to / Thu nhỏ lõi.<br>
        • Di chuyển tay: Quay & nghiêng camera.<br>
        • Tự động: lõi chậm quay, các vòng xoay độc lập để tạo chiều sâu.
      </div>
    </div>
  </div>

  <div id="hud-wrapper">
    <div class="guide">
      <div><b>Tips:</b> Giữ tay trong khung để điều khiển trực quan.</div>
    </div>
    <div class="cam-box">
      <video class="input_video" playsinline webkit-playsinline muted autoplay></video>
      <canvas class="output_canvas"></canvas>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

  <script>
    // ---------- Performance & device heuristics ----------
    const isMobile = /Mobi|Android/i.test(navigator.userAgent) || window.innerWidth < 720;
    const STAR_COUNT = isMobile ? 1200 : 4000; // fewer on mobile

    // ---------- Canvas references ----------
    const bgCanvas = document.getElementById('bg-canvas');
    const mainCanvas = document.getElementById('main-canvas');
    const postCanvas = document.getElementById('post-canvas');

    // Size helper
    function setSize() {
      [bgCanvas, mainCanvas, postCanvas].forEach(c => {
        c.width = window.innerWidth * devicePixelRatio;
        c.height = window.innerHeight * devicePixelRatio;
        c.style.width = window.innerWidth + 'px';
        c.style.height = window.innerHeight + 'px';
      });
    }
    setSize();
    window.addEventListener('resize', () => { setSize(); onWindowResize(); });

    // ---------- Background: Deep starfield + volumetric dust ----------
    const bgCtx = bgCanvas.getContext('2d');
    function drawBackground(time) {
      const w = bgCanvas.width, h = bgCanvas.height;
      bgCtx.clearRect(0,0,w,h);
      // subtle gradient
      const gradient = bgCtx.createLinearGradient(0,0,0,h);
      gradient.addColorStop(0, '#000010');
      gradient.addColorStop(1, '#000018');
      bgCtx.fillStyle = gradient;
      bgCtx.fillRect(0,0,w,h);

      // star layer
      bgCtx.globalCompositeOperation = 'lighter';
      for (let i=0;i<STAR_COUNT;i++){
        // pseudo-random but deterministic per index
        const rnd = (i*9301+49297)%233280/233280;
        const x = (rnd * (w))|0;
        const y = ((i*7+ (time*0.00002* (i%7+1)))%h)|0;
        const size = (i%13===0)?(1.6*devicePixelRatio):((i%17===0)?1.2*devicePixelRatio:0.6*devicePixelRatio);
        bgCtx.beginPath();
        bgCtx.fillStyle = 'rgba(255,255,255,' + (0.35 + (i%19)/80) + ')';
        bgCtx.arc(x,y,size,0,Math.PI*2);
        bgCtx.fill();
      }

      // volumetric dust streaks
      for (let s=0;s<60;s++){
        const alpha = 0.02 + (s%7)/200;
        bgCtx.fillStyle = 'rgba(120,160,255,'+alpha+')';
        const x = (time*0.01 + s*137) % w;
        bgCtx.fillRect((x-0.2*devicePixelRatio)|0,0,(2+Math.sin(time*0.0002+s)*8)|0,h);
      }

      bgCtx.globalCompositeOperation = 'source-over';
    }

    // ---------- THREE.JS: Epic Core Scene ----------
    let scene, camera, renderer, group;
    let innerCore, midCore, outerShell, ringMeshes = [], particleCloud;

    function initThree(){
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000011, 0.0012);

      camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 4000);
      camera.position.set(0, 8, 28);

      renderer = new THREE.WebGLRenderer({canvas: mainCanvas, antialias: true, alpha: true});
      renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
      renderer.setSize(window.innerWidth, window.innerHeight);

      // Lighting
      const amb = new THREE.AmbientLight(0x081020, 0.8);
      scene.add(amb);
      const key = new THREE.PointLight(0xffffff, 4, 800, 2);
      key.position.set(0,0,60);
      scene.add(key);
      const rim1 = new THREE.PointLight(0x00f2ff, 2.2, 500);
      rim1.position.set(60,30,10);
      scene.add(rim1);
      const rim2 = new THREE.PointLight(0xbd00ff, 1.8, 500);
      rim2.position.set(-60,-30,10);
      scene.add(rim2);

      // Group root
      group = new THREE.Group();
      scene.add(group);

      // INNER CORE: energetic plasma
      const innerGeo = new THREE.IcosahedronGeometry(3.2, 5);
      const innerMat = new THREE.MeshStandardMaterial({
        emissive: 0x66f8ff,
        emissiveIntensity: 1.2,
        roughness: 0.1,
        metalness: 0.0,
        transparent: true,
        opacity: 0.95
      });
      innerCore = new THREE.Mesh(innerGeo, innerMat);
      innerCore.scale.set(0.85,0.85,0.85);
      group.add(innerCore);

      // MID CORE: molten metallic shell
      const midGeo = new THREE.OctahedronGeometry(5.8, 2);
      const midMat = new THREE.MeshStandardMaterial({
        color: 0x0b0b0b,
        metalness: 0.9,
        roughness: 0.15,
        emissive: 0x220033,
        emissiveIntensity: 0.35,
        envMapIntensity: 1.0,
        side: THREE.DoubleSide
      });
      midCore = new THREE.Mesh(midGeo, midMat);
      midCore.material.onBeforeCompile = shader => {
        // subtle rim glow via vertex displacement (lightweight)
        shader.fragmentShader = shader.fragmentShader.replace(
          'void main() {',
          'varying float vNormalDot; void main() {'
        ).replace(
          'gl_FragColor = vec4( outgoingLight, diffuseColor.a );',
          'float rim = pow(1.0 - vNormalDot, 2.5); gl_FragColor = vec4(outgoingLight + vec3(0.08,0.18,0.22) * rim, diffuseColor.a );'
        );
        shader.vertexShader = 'varying float vNormalDot;'+shader.vertexShader.replace(
          'void main() {',
          'void main() {'
        ).replace(
          '#include <beginnormal_vertex>',
          '#include <beginnormal_vertex>\n vNormalDot = dot( normal, normalize( vec3(0.0,0.0,1.0) ) );'
        );
      };
      group.add(midCore);

      // OUTER SHELL: segmented plates
      const plateCount = 18;
      outerShell = new THREE.Group();
      for(let i=0;i<plateCount;i++){
        const plate = new THREE.Mesh(new THREE.BoxGeometry(12,0.8,6), new THREE.MeshStandardMaterial({
          color: (i%2===0)?0x03030b:0x06061a,
          metalness: 0.8, roughness: 0.1, emissive: (i%2===0)?0x001526:0x15001a, emissiveIntensity:0.08
        }));
        const ang = (i/plateCount)*Math.PI*2;
        plate.position.set(Math.cos(ang)*9, Math.sin(ang)*9, 0);
        plate.rotation.z = ang + Math.PI/2;
        plate.userData = {rotSpeed: (0.001 + Math.random()*0.003) * (i%2?1:-1)};
        outerShell.add(plate);
      }
      group.add(outerShell);

      // RINGS: multiple orbiting rings with glow
      for(let r=0;r<6;r++){
        const radius = 11 + r*2.5;
        const tor = new THREE.TorusGeometry(radius, 0.25 + r*0.06, 8, 240);
        const mat = new THREE.MeshStandardMaterial({
          emissive: (r%2===0)?0x00f2ff:0xbd00ff,
          emissiveIntensity: 0.9 - r*0.08,
          metalness: 0.2, roughness: 0.05,
          transparent: true, opacity: 0.9
        });
        const mesh = new THREE.Mesh(tor, mat);
        mesh.rotation.x = Math.random()*Math.PI;
        mesh.rotation.y = Math.random()*Math.PI;
        mesh.userData = {rotSpeedX: (Math.random()-0.5)*0.006, rotSpeedY: (Math.random()-0.5)*0.006};
        group.add(mesh);
        ringMeshes.push(mesh);
      }

      // PARTICLE CLOUD around core (3D points)
      const pcount = isMobile?1500:6000;
      const pGeo = new THREE.BufferGeometry();
      const pos = new Float32Array(pcount*3);
      const sizes = new Float32Array(pcount);
      for(let i=0;i<pcount;i++){
        const r = 20 + Math.random()*160;
        const theta = Math.random()*Math.PI*2;
        const phi = (Math.random()-0.5)*Math.PI;
        pos[i*3] = Math.cos(theta)*Math.cos(phi)*r;
        pos[i*3+1] = Math.sin(phi)*r*0.6;
        pos[i*3+2] = Math.sin(theta)*Math.cos(phi)*r;
        sizes[i] = 0.5 + Math.random()*2.5;
      }
      pGeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
      pGeo.setAttribute('size', new THREE.BufferAttribute(sizes,1));
      const pMat = new THREE.PointsMaterial({size: isMobile?0.8:1.6,sizeAttenuation:true,alphaTest:0.001,transparent:true,opacity:0.95,blending:THREE.AdditiveBlending});
      particleCloud = new THREE.Points(pGeo,pMat);
      scene.add(particleCloud);

      // subtle camera orbital target
      camera.lookAt(0,0,0);
    }

    initThree();

    // ---------- Resize helper for three ----------
    function onWindowResize(){
      if(!camera||!renderer) return;
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ---------- Mediapipe Hands & HUD ----------
    const videoElement = document.querySelector('.input_video');
    const canvasElement = document.querySelector('.output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const loadingDiv = document.getElementById('loading');

    let targetScale = 1;
    let currentScale = 1;
    let targetRotX = 0, targetRotY = 0;
    let lastX = 0.5, lastY = 0.5;

    function onResults(results){
      loadingDiv.style.display = 'none';
      canvasElement.width = videoElement.videoWidth;
      canvasElement.height = videoElement.videoHeight;
      canvasCtx.save();
      canvasCtx.clearRect(0,0,canvasElement.width,canvasElement.height);

      if(results.multiHandLandmarks && results.multiHandLandmarks.length){
        const lm = results.multiHandLandmarks[0];
        drawConnectors(canvasCtx, lm, HAND_CONNECTIONS, {color:'#00f2cc',lineWidth:2});
        drawLandmarks(canvasCtx, lm, {color:'#ff66dd',lineWidth:1,radius:2});

        const wrist = lm[0];
        const midTip = lm[12];
        const dist = Math.hypot(midTip.x - wrist.x, midTip.y - wrist.y);
        let openness = (dist - 0.07) * 5.5;
        openness = Math.max(0.5, Math.min(2.6, openness));
        targetScale = openness;

        const palmX = lm[9].x; const palmY = lm[9].y;
        const sensitivity = 6.0;
        targetRotY += (palmX - lastX) * -sensitivity;
        targetRotX += (palmY - lastY) * sensitivity;
        lastX = palmX; lastY = palmY;
      } else {
        // gentle idle motion
        targetScale = 1.0;
        targetRotY += 0.0015;
      }
      canvasCtx.restore();
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({maxNumHands:1,modelComplexity:1,minDetectionConfidence:0.55,minTrackingConfidence:0.55});
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {onFrame: async ()=>{ await hands.send({image:videoElement}); }, width: isMobile?360:640, height: isMobile?480:720});
    cameraUtils.start().catch(err=>{ loadingDiv.innerText = 'Lỗi Camera: ' + err; });

    // ---------- Main animation loop ----------
    let tStart = performance.now();
    function renderFrame(t){
      const time = t - tStart;
      requestAnimationFrame(renderFrame);

      // Background canvas
      drawBackground(t);

      // smooth lerp scale & rotation
      currentScale += (targetScale - currentScale) * 0.08;
      group.scale.setScalar(currentScale);
      group.rotation.y += (targetRotY - group.rotation.y) * 0.08;
      group.rotation.x += (targetRotX - group.rotation.x) * 0.06;

      // animate components
      if(innerCore){ innerCore.rotation.x += 0.0035; innerCore.rotation.y += 0.007; }
      if(midCore){ midCore.rotation.y -= 0.0016; }
      if(outerShell){ outerShell.children.forEach((p,i)=> p.rotation.z += p.userData.rotSpeed); }
      ringMeshes.forEach(r=>{ r.rotation.x += r.userData.rotSpeedX; r.rotation.y += r.userData.rotSpeedY; });

      // particle cloud subtle drift
      if(particleCloud){ particleCloud.rotation.y += 0.0006; particleCloud.rotation.x = Math.sin(time*0.00006)*0.03; }

      // camera subtle bob
      camera.position.x += (Math.sin(time*0.00027) * 0.05 - camera.position.x) * 0.02;
      camera.position.y += (Math.cos(time*0.00019) * 0.05 - camera.position.y) * 0.02;
      camera.lookAt(0,0,0);

      renderer.render(scene, camera);

      // lightweight post-processing: draw additive glow to postCanvas
      const postCtx = postCanvas.getContext('2d');
      postCtx.clearRect(0,0,postCanvas.width, postCanvas.height);
      postCtx.globalCompositeOperation = 'lighter';
      // sample a glow around center — approximate bloom using radial gradient
      const cx = postCanvas.width/2, cy = postCanvas.height/2;
      const grad = postCtx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(cx,cy)*0.9);
      grad.addColorStop(0, 'rgba(0,255,220,0.06)');
      grad.addColorStop(0.25, 'rgba(80,40,120,0.02)');
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      postCtx.fillStyle = grad;
      postCtx.fillRect(0,0,postCanvas.width, postCanvas.height);
      postCtx.globalCompositeOperation = 'source-over';
    }
    requestAnimationFrame(renderFrame);

    // ---------- Initialization guard ----------
    // Ensure Three scene is ready when loaded
    function ensureInit(){ if(!scene) initThree(); }
    ensureInit();

  </script>
</body>

</html>