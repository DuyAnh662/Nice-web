<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸŒŒ HYPER CORE - VÅ© Trá»¥ HÃ¹ng VÄ© ğŸŒŒ</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: radial-gradient(ellipse at center, #0a0015 0%, #000000 100%);
            font-family: 'Orbitron', sans-serif;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #canvas3d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Cosmic Overlay Glow */
        .cosmic-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
            background:
                radial-gradient(ellipse at 50% 50%, transparent 0%, rgba(0, 0, 0, 0.3) 100%);
        }

        /* Title */
        .title-container {
            position: fixed;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            text-align: center;
            pointer-events: none;
        }

        .main-title {
            font-size: clamp(1.5rem, 5vw, 4rem);
            font-weight: 900;
            background: linear-gradient(135deg,
                    #ff00ff 0%,
                    #00ffff 25%,
                    #ffff00 50%,
                    #ff00ff 75%,
                    #00ffff 100%);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradient-shift 3s ease infinite, glow-pulse 2s ease-in-out infinite;
            text-shadow: 0 0 60px rgba(255, 0, 255, 0.5);
            letter-spacing: 0.3em;
        }

        @keyframes gradient-shift {

            0%,
            100% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }
        }

        @keyframes glow-pulse {

            0%,
            100% {
                filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.5));
            }

            50% {
                filter: drop-shadow(0 0 40px rgba(255, 0, 255, 0.8));
            }
        }

        .subtitle {
            font-size: clamp(0.6rem, 1.5vw, 1rem);
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 0.5em;
            margin-top: 1rem;
            animation: fadeIn 2s ease 1s both;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Loading Screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 1s ease, visibility 1s ease;
        }

        #loading.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .loader-ring {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            position: relative;
        }

        .loader-ring::before,
        .loader-ring::after {
            content: '';
            position: absolute;
            border-radius: 50%;
        }

        .loader-ring::before {
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 4px solid transparent;
            border-top-color: #ff00ff;
            border-right-color: #00ffff;
            animation: spin 1s linear infinite;
        }

        .loader-ring::after {
            top: 15px;
            left: 15px;
            right: 15px;
            bottom: 15px;
            border: 4px solid transparent;
            border-bottom-color: #ffff00;
            border-left-color: #ff00ff;
            animation: spin 0.8s linear infinite reverse;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loader-text {
            color: #00ffff;
            font-size: 0.9rem;
            margin-top: 2rem;
            letter-spacing: 0.3em;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.5;
            }

            50% {
                opacity: 1;
            }
        }

        /* HUD Wrapper */
        #hud-wrapper {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            pointer-events: none;
        }

        .guide-box {
            margin-bottom: 15px;
            background: rgba(0, 10, 30, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #fff;
            padding: 15px 20px;
            border-radius: 15px;
            font-size: 13px;
            width: 220px;
            text-align: right;
            backdrop-filter: blur(10px);
            box-shadow:
                0 0 30px rgba(0, 255, 255, 0.1),
                inset 0 0 30px rgba(0, 255, 255, 0.05);
        }

        .guide-box div {
            margin: 8px 0;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 10px;
        }

        .guide-box b {
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .cam-box {
            position: relative;
            width: 180px;
            height: 135px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            overflow: hidden;
            box-shadow:
                0 0 30px rgba(0, 255, 255, 0.2),
                inset 0 0 20px rgba(0, 255, 255, 0.1);
            transform: scaleX(-1);
            pointer-events: auto;
        }

        .input_video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Interactive Info */
        .info-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.7rem;
            letter-spacing: 0.1em;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .cam-box {
                width: 140px;
                height: 105px;
            }

            .guide-box {
                width: 180px;
                font-size: 11px;
                padding: 12px 15px;
            }

            .info-panel {
                display: none;
            }
        }
    </style>
</head>

<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="loader-ring"></div>
        <div class="loader-text">KHá»I Äá»˜NG VÅ¨ TRá»¤</div>
    </div>

    <!-- Cosmic Overlay -->
    <div class="cosmic-overlay"></div>

    <!-- Title -->
    <div class="title-container">
        <h1 class="main-title">HYPER CORE</h1>
        <p class="subtitle">ÄIá»€U KHIá»‚N Báº°NG BÃ€N TAY</p>
    </div>

    <!-- 3D Canvas Container -->
    <div id="canvas-container">
        <canvas id="canvas3d"></canvas>
    </div>

    <!-- HUD -->
    <div id="hud-wrapper">
        <div class="guide-box">
            <div>ğŸ–ï¸ <b>Má»Ÿ tay:</b> PhÃ³ng to</div>
            <div>âœŠ <b>Náº¯m tay:</b> Thu nhá»</div>
            <div>ğŸ‘‹ <b>Di chuyá»ƒn:</b> Xoay camera</div>
            <div style="color: rgba(255,255,255,0.4); font-style: italic; margin-top: 10px;">
                Äáº·t tay vÃ o khung bÃªn dÆ°á»›i
            </div>
        </div>
        <div class="cam-box">
            <video class="input_video" playsinline webkit-playsinline muted autoplay></video>
            <canvas class="output_canvas"></canvas>
        </div>
    </div>

    <!-- Info Panel -->
    <div class="info-panel">
        FPS: <span id="fps">60</span> |
        SCALE: <span id="scale-info">1.00</span>
    </div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   HYPER CORE - SIÃŠU Váº¬T THá»‚ VÅ¨ TRá»¤  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const canvas3d = document.getElementById('canvas3d');
        const loadingDiv = document.getElementById('loading');
        const fpsDisplay = document.getElementById('fps');
        const scaleInfo = document.getElementById('scale-info');

        // Three.js Core
        let scene, camera, renderer;
        let hyperCore, particleSystems = [], nebulaClouds = [];
        let time = 0;
        let lastTime = performance.now();
        let frameCount = 0;

        // Control Variables
        let targetScale = 1, currentScale = 1;
        let targetRotX = 0, targetRotY = 0;
        let lastX = 0.5, lastY = 0.5;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  KHá»I Táº O THREE.JS  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function init3D() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000011, 0.008);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.z = 25;

            // Renderer
            renderer = new THREE.WebGLRenderer({
                canvas: canvas3d,
                antialias: true,
                alpha: false,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  ÃNH SÃNG HÃ™NG VÄ¨  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Core Light - LÃµi phÃ¡t sÃ¡ng máº¡nh
            const coreLight = new THREE.PointLight(0xffffff, 3, 100);
            coreLight.position.set(0, 0, 0);
            scene.add(coreLight);

            // Dramatic Spotlights
            const colors = [0xff00ff, 0x00ffff, 0xffff00, 0xff0088, 0x00ff88];
            colors.forEach((color, i) => {
                const angle = (i / colors.length) * Math.PI * 2;
                const light = new THREE.PointLight(color, 1.5, 80);
                light.position.set(
                    Math.cos(angle) * 30,
                    Math.sin(angle * 2) * 20,
                    Math.sin(angle) * 30
                );
                scene.add(light);
            });

            // Ambient for subtle fill
            scene.add(new THREE.AmbientLight(0x111122, 0.3));

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  HYPER CORE  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            hyperCore = new THREE.Group();
            scene.add(hyperCore);

            // â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“ 1. NÄ‚NG LÆ¯á»¢NG LÃ•I - ENERGY CORE â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“

            // Inner Plasma Core
            const plasmaGeo = new THREE.IcosahedronGeometry(1.2, 4);
            const plasmaMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.95
            });
            const plasmaCore = new THREE.Mesh(plasmaGeo, plasmaMat);
            plasmaCore.userData.type = 'plasma';
            hyperCore.add(plasmaCore);

            // Energy Field Layers
            for (let i = 0; i < 4; i++) {
                const size = 1.5 + i * 0.4;
                const geo = new THREE.IcosahedronGeometry(size, 2);
                const mat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(i * 0.15, 1, 0.6),
                    wireframe: true,
                    transparent: true,
                    opacity: 0.4 - i * 0.08
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.userData = {
                    type: 'energy',
                    rotSpeed: { x: 0.02 - i * 0.003, y: 0.015 - i * 0.002, z: 0.01 }
                };
                hyperCore.add(mesh);
            }

            // â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“ 2. Vá» GIÃP CÆ  KHÃ - TECH SHELL â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“

            // Outer Icosahedron Shell
            const shellGeo = new THREE.IcosahedronGeometry(4, 1);
            const shellMat = new THREE.MeshPhongMaterial({
                color: 0x000000,
                emissive: 0x00ffff,
                emissiveIntensity: 0.15,
                wireframe: true,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const outerShell = new THREE.Mesh(shellGeo, shellMat);
            outerShell.userData = { type: 'shell', rotSpeed: { x: -0.005, y: -0.008, z: 0.003 } };
            hyperCore.add(outerShell);

            // Secondary Dodecahedron Shell
            const shell2Geo = new THREE.DodecahedronGeometry(5.5, 0);
            const shell2Mat = new THREE.MeshPhongMaterial({
                color: 0x110022,
                emissive: 0xff00ff,
                emissiveIntensity: 0.1,
                wireframe: true,
                transparent: true,
                opacity: 0.4
            });
            const shell2 = new THREE.Mesh(shell2Geo, shell2Mat);
            shell2.userData = { type: 'shell2', rotSpeed: { x: 0.003, y: -0.004, z: -0.002 } };
            hyperCore.add(shell2);

            // â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“ 3. Há»† THá»NG VÃ’NG XOAY - RING SYSTEM â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“

            const ringConfigs = [
                { radius: 6, tube: 0.08, color: 0x00ffff, speed: 0.02 },
                { radius: 7, tube: 0.06, color: 0xff00ff, speed: -0.015 },
                { radius: 8, tube: 0.1, color: 0xffff00, speed: 0.018 },
                { radius: 9.5, tube: 0.05, color: 0x00ff88, speed: -0.012 },
                { radius: 11, tube: 0.12, color: 0xff0088, speed: 0.01 },
                { radius: 13, tube: 0.04, color: 0x00ffff, speed: -0.008 },
                { radius: 15, tube: 0.08, color: 0xff00ff, speed: 0.006 }
            ];

            ringConfigs.forEach((config, i) => {
                const ringGeo = new THREE.TorusGeometry(config.radius, config.tube, 32, 200);
                const ringMat = new THREE.MeshPhongMaterial({
                    color: config.color,
                    emissive: config.color,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);

                // GÃ³c nghiÃªng ngáº«u nhiÃªn nhÆ°ng Ä‘áº¹p
                ring.rotation.x = Math.random() * Math.PI;
                ring.rotation.y = Math.random() * Math.PI * 0.5;

                ring.userData = {
                    type: 'ring',
                    baseRotX: ring.rotation.x,
                    baseRotY: ring.rotation.y,
                    speed: config.speed,
                    wobble: Math.random() * 0.5
                };
                hyperCore.add(ring);
            });

            // â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“ 4. ORBITAL SPHERES - QUá»¸ Äáº O Cáº¦U â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“

            const orbitalColors = [0xff00ff, 0x00ffff, 0xffff00, 0x00ff88, 0xff5500];
            for (let i = 0; i < 12; i++) {
                const orbitRadius = 10 + Math.random() * 8;
                const sphereSize = 0.15 + Math.random() * 0.25;

                const sphereGeo = new THREE.SphereGeometry(sphereSize, 16, 16);
                const sphereMat = new THREE.MeshBasicMaterial({
                    color: orbitalColors[i % orbitalColors.length],
                    transparent: true,
                    opacity: 0.9
                });
                const sphere = new THREE.Mesh(sphereGeo, sphereMat);

                sphere.userData = {
                    type: 'orbital',
                    orbitRadius: orbitRadius,
                    orbitSpeed: 0.3 + Math.random() * 0.5,
                    orbitOffset: Math.random() * Math.PI * 2,
                    orbitTilt: (Math.random() - 0.5) * Math.PI * 0.8
                };
                hyperCore.add(sphere);
            }

            // â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“ 5. ENERGY BEAMS - TIA NÄ‚NG LÆ¯á»¢NG â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“

            const beamCount = 8;
            for (let i = 0; i < beamCount; i++) {
                const angle = (i / beamCount) * Math.PI * 2;

                const beamGeo = new THREE.CylinderGeometry(0.03, 0.08, 20, 8);
                const beamMat = new THREE.MeshBasicMaterial({
                    color: i % 2 === 0 ? 0x00ffff : 0xff00ff,
                    transparent: true,
                    opacity: 0.4
                });
                const beam = new THREE.Mesh(beamGeo, beamMat);

                beam.rotation.z = angle;
                beam.rotation.x = Math.PI / 2;
                beam.position.set(
                    Math.cos(angle) * 10,
                    0,
                    Math.sin(angle) * 10
                );

                beam.userData = { type: 'beam', angle: angle };
                hyperCore.add(beam);
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  STARFIELD VÅ¨ TRá»¤  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Deep Space Stars
            createStarfield(8000, 300, 0.15, 0xffffff);
            createStarfield(3000, 400, 0.25, 0x88aaff);
            createStarfield(1000, 500, 0.4, 0xffaa88);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  NEBULA CLOUDS  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            createNebulaClouds();

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  PARTICLE SYSTEMS  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Core Energy Particles
            createParticleSystem(2000, 15, [0x00ffff, 0xff00ff, 0xffff00]);

            // Outer Cosmic Dust
            createParticleSystem(1500, 40, [0x4444ff, 0xff44ff, 0x44ffff]);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  HELPER FUNCTIONS  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function createStarfield(count, range, size, color) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);

            for (let i = 0; i < count * 3; i += 3) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = range * (0.5 + Math.random() * 0.5);

                positions[i] = r * Math.sin(phi) * Math.cos(theta);
                positions[i + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i + 2] = r * Math.cos(phi);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: color,
                size: size,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            const stars = new THREE.Points(geometry, material);
            stars.userData = { type: 'starfield' };
            scene.add(stars);
        }

        function createNebulaClouds() {
            const nebulaColors = [0xff00ff, 0x00ffff, 0x4400ff, 0xff0044];

            for (let i = 0; i < 6; i++) {
                const geometry = new THREE.SphereGeometry(30 + Math.random() * 40, 32, 32);
                const material = new THREE.MeshBasicMaterial({
                    color: nebulaColors[i % nebulaColors.length],
                    transparent: true,
                    opacity: 0.02,
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide
                });

                const nebula = new THREE.Mesh(geometry, material);
                nebula.position.set(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100 - 50
                );
                nebula.userData = {
                    type: 'nebula',
                    pulseSpeed: 0.5 + Math.random() * 0.5
                };
                scene.add(nebula);
                nebulaClouds.push(nebula);
            }
        }

        function createParticleSystem(count, range, colors) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const particleColors = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                const radius = Math.random() * range;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = radius * Math.cos(phi);

                const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
                particleColors[i3] = color.r;
                particleColors[i3 + 1] = color.g;
                particleColors[i3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.1,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                vertexColors: true,
                sizeAttenuation: true
            });

            const particles = new THREE.Points(geometry, material);
            particles.userData = {
                type: 'particles',
                rotSpeed: { x: 0.001, y: 0.002, z: 0.0005 }
            };
            scene.add(particles);
            particleSystems.push(particles);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  MEDIAPIPE HANDS  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const videoElement = document.querySelector('.input_video');
        const canvasElement = document.querySelector('.output_canvas');
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            // áº¨n loading khi Ä‘Ã£ nháº­n frame
            loadingDiv.classList.add('hidden');

            // Váº½ lÃªn canvas mini
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // Váº½ xÆ°Æ¡ng tay neon
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
                    color: '#00ffff',
                    lineWidth: 3
                });
                drawLandmarks(canvasCtx, landmarks, {
                    color: '#ff00ff',
                    lineWidth: 2,
                    radius: 4
                });

                // LOGIC ÄIá»€U KHIá»‚N
                const wrist = landmarks[0];
                const middleTip = landmarks[12];

                // TÃ­nh khoáº£ng cÃ¡ch (Zoom)
                const distance = Math.sqrt(
                    Math.pow(middleTip.x - wrist.x, 2) +
                    Math.pow(middleTip.y - wrist.y, 2)
                );

                let openness = (distance - 0.1) * 5;
                openness = Math.max(0.3, Math.min(2.5, openness));
                targetScale = openness;

                // TÃ­nh vá»‹ trÃ­ (Xoay)
                const palmX = landmarks[9].x;
                const palmY = landmarks[9].y;
                const sensitivity = 4;

                targetRotY += (palmX - lastX) * -sensitivity;
                targetRotX += (palmY - lastY) * sensitivity;

                lastX = palmX;
                lastY = palmY;
            } else {
                // KhÃ´ng tháº¥y tay: auto-rotate nháº¹
                targetScale = 1;
                targetRotY += 0.003;
            }
            canvasCtx.restore();
        }

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 480,
            height: 640
        });

        cameraUtils.start().catch(err => {
            console.error('Camera error:', err);
            loadingDiv.innerHTML = `
                <div style="color: #ff4444; text-align: center; padding: 20px;">
                    âŒ Lá»–I CAMERA<br>
                    <small style="color: #888;">${err}</small><br>
                    <small style="color: #666; margin-top: 10px; display: block;">
                        HÃ£y cho phÃ©p truy cáº­p camera
                    </small>
                </div>
            `;
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  ANIMATION LOOP  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // FPS Counter
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fpsDisplay.textContent = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }

            // Lerp Ä‘á»ƒ mÆ°á»£t chuyá»ƒn Ä‘á»™ng
            currentScale += (targetScale - currentScale) * 0.08;
            scaleInfo.textContent = currentScale.toFixed(2);

            if (hyperCore) {
                hyperCore.scale.set(currentScale, currentScale, currentScale);
                hyperCore.rotation.y += (targetRotY - hyperCore.rotation.y) * 0.05;
                hyperCore.rotation.x += (targetRotX - hyperCore.rotation.x) * 0.05;

                // Animate tá»«ng thÃ nh pháº§n
                hyperCore.children.forEach(child => {
                    const userData = child.userData;

                    if (userData.type === 'plasma') {
                        // Nhá»‹p Ä‘áº­p lÃµi nÄƒng lÆ°á»£ng
                        const pulse = 1 + Math.sin(time * 3) * 0.1;
                        child.scale.set(pulse, pulse, pulse);
                    }

                    if (userData.rotSpeed) {
                        child.rotation.x += userData.rotSpeed.x;
                        child.rotation.y += userData.rotSpeed.y;
                        if (userData.rotSpeed.z) child.rotation.z += userData.rotSpeed.z;
                    }

                    if (userData.type === 'ring') {
                        child.rotation.z += userData.speed;
                        // Wobble effect
                        child.rotation.x = userData.baseRotX + Math.sin(time + userData.wobble) * 0.05;
                    }

                    if (userData.type === 'orbital') {
                        const t = time * userData.orbitSpeed + userData.orbitOffset;
                        child.position.x = Math.cos(t) * userData.orbitRadius;
                        child.position.y = Math.sin(t * 0.5) * userData.orbitRadius * 0.3;
                        child.position.z = Math.sin(t) * userData.orbitRadius;

                        // Nháº¥p nhÃ¡y
                        child.material.opacity = 0.5 + Math.sin(time * 5 + userData.orbitOffset) * 0.4;
                    }

                    if (userData.type === 'beam') {
                        // Xoay tia nÄƒng lÆ°á»£ng
                        child.rotation.z = userData.angle + time * 0.5;
                        child.material.opacity = 0.2 + Math.sin(time * 3) * 0.2;
                    }
                });
            }

            // Animate particles
            particleSystems.forEach(ps => {
                if (ps.userData.rotSpeed) {
                    ps.rotation.x += ps.userData.rotSpeed.x;
                    ps.rotation.y += ps.userData.rotSpeed.y;
                    ps.rotation.z += ps.userData.rotSpeed.z;
                }
            });

            // Animate nebula clouds
            nebulaClouds.forEach((nebula, i) => {
                nebula.material.opacity = 0.015 + Math.sin(time * nebula.userData.pulseSpeed + i) * 0.01;
                nebula.rotation.y += 0.0005;
            });

            // Starfield subtle rotation theo camera
            scene.children.forEach(child => {
                if (child.userData && child.userData.type === 'starfield') {
                    child.rotation.y = hyperCore.rotation.y * 0.1;
                    child.rotation.x = hyperCore.rotation.x * 0.05;
                }
            });

            renderer.render(scene, camera);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  RESIZE HANDLER  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  KHá»I Äá»˜NG  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        init3D();
        animate();

        console.log('%cğŸŒŒ HYPER CORE - VÅ© Trá»¥ HÃ¹ng VÄ© ğŸŒŒ',
            'font-size: 20px; color: #00ffff; text-shadow: 0 0 20px #ff00ff;');
        console.log('%cÄiá»u khiá»ƒn báº±ng tay - Powered by Three.js & MediaPipe',
            'font-size: 12px; color: #ff00ff;');
    </script>
</body>

</html>