<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CYBER CORE by Gemini</title>
    <!-- Th√™m font hi·ªán ƒë·∫°i -->
    <link href="fonts.googleapis.com" rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00fffb;
            --dark-bg: #000000;
            --accent-purple: #ff00ff;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--dark-bg);
            font-family: 'Share Tech Mono', monospace;
            color: var(--neon-blue);
        }

        /* Container cho 3D */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #canvas3d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
        }

        /* M√†n h√¨nh ch·ªù */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--neon-blue);
            font-size: 20px;
            z-index: 20;
            pointer-events: none;
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 25px 40px;
            border-radius: 5px;
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 20px rgba(0, 255, 251, 0.5);
            font-family: 'Orbitron', sans-serif;
            animation: pulse 1.5s infinite alternate;
        }

        @keyframes pulse {
            from { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            to { transform: translate(-50%, -50%) scale(1.05); opacity: 0.8; }
        }

        /* --- KAW V·ª∞C HUD (Webcam Mini) --- */
        #hud-wrapper {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .cam-box {
            position: relative;
            width: 180px; /* L·ªõn h∆°n ch√∫t */
            height: 135px;
            border: 2px solid var(--neon-blue);
            background: #000;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(0, 255, 251, 0.5);
            transform: scaleX(-1); /* L·∫≠t ng∆∞·ª£c g∆∞∆°ng gi·ªëng soi g∆∞∆°ng */
            margin-top: 10px;
        }

        .input_video, .output_canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
        }

        /* H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng */
        .guide-box {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--accent-purple);
            color: #fff;
            padding: 15px;
            border-radius: 5px;
            font-size: 13px;
            width: 250px;
            text-align: right;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.3);
        }

        .guide-box b {
            color: var(--neon-blue);
            font-family: 'Orbitron', sans-serif;
        }

        /* Ch·ªâ hi·ªÉn th·ªã tr√™n mobile */
        @media (max-width: 600px) {
            .cam-box {
                width: 120px;
                height: 160px; /* Camera d·ªçc cho ƒëi·ªán tho·∫°i */
            }
            .guide-box {
                width: 180px;
                font-size: 11px;
            }
            #hud-wrapper {
                bottom: 10px;
                right: 10px;
            }
            #loading {
                font-size: 16px;
                padding: 15px 25px;
            }
        }
    </style>
</head>

<body>

    <div id="loading">
        üöÄ Initiating Cyber Core System...<br>
        <small>Vui l√≤ng ch·ªù & Cho ph√©p Camera</small>
    </div>

    <div id="canvas-container">
        <!-- Canvas cho hi·ªáu ·ª©ng h·∫°t n·ªÅn (particles) -->
        <canvas id="canvas1"></canvas>
        <!-- Canvas cho v·∫≠t th·ªÉ 3D ch√≠nh -->
        <canvas id="canvas3d"></canvas>
    </div>
    
    <div id="hud-wrapper">
        <div class="guide-box">
            <div>üñê <b>M·ªû TAY:</b> Ph√≥ng to Core</div>
            <div>‚úä <b>N·∫ÆM TAY:</b> Thu nh·ªè Core</div>
            <div>üëã <b>DI CHUY·ªÇN:</b> Xoay Camera</div>
            <div style="margin-top:8px; color:var(--accent-purple); font-style:italic; border-top: 1px dashed;">[ Input Feed ]</div>
        </div>

        <div class="cam-box">
            <video class="input_video" playsinline webkit-playsinline muted autoplay></video>
            <canvas class="output_canvas"></canvas>
        </div>
    </div>

    <!-- Th∆∞ vi·ªán Three.js v√† MediaPipe -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <!-- Th∆∞ vi·ªán Three.js post-processing cho hi·ªáu ·ª©ng h√†o quang -->
    <script src="unpkg.com"></script>
    <script src="unpkg.com"></script>
    <script src="unpkg.com"></script>
    <script src="unpkg.com"></script>
    <script src="unpkg.com"></script>


    <script>
        // --- 1. SETUP THREE.JS (ƒê·ªí H·ªåA ƒê·ªí S·ªò) ---
        const container = document.getElementById('canvas-container');
        const canvas3d = document.getElementById('canvas3d');

        let scene, camera, renderer, coreGroup, innerCore, outerShell, ringSystem, stars, composer;

        function init3D() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001); // S∆∞∆°ng m√π d√†y h∆°n cho c·∫£m gi√°c s√¢u

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.z = 15; // Camera l√πi xa h∆°n ƒë·ªÉ th·∫•y s·ª± "ƒë·ªì s·ªô"

            renderer = new THREE.WebGLRenderer({ canvas: canvas3d, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 0); // Clear color transparent if needed

            // √Ånh s√°ng k·ªãch t√≠nh
            const ambientLight = new THREE.AmbientLight(0x444444);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0x00fffb, 5, 200);
            pointLight1.position.set(10, 10, 10);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xff00ff, 5, 200);
            pointLight2.position.set(-10, -10, 10);
            scene.add(pointLight2);

            const coreLight = new THREE.PointLight(0xffffff, 3, 80);
            coreLight.position.set(0, 0, 0);
            scene.add(coreLight);

            // V·∫¨T TH·ªÇ: "CYBER CORE"
            coreGroup = new THREE.Group();
            scene.add(coreGroup);

            // 1. L√µi NƒÉng L∆∞·ª£ng Ch√≠nh (Sun/Star)
            const coreGeo = new THREE.IcosahedronGeometry(1.5, 4); // To h∆°n, m∆∞·ª£t h∆°n
            const coreMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });
            innerCore = new THREE.Mesh(coreGeo, coreMat);
            coreGroup.add(innerCore);

            // 2. V·ªè Gi√°p C∆° Kh√≠ (Tech Shell)
            const shellGeo = new THREE.IcosahedronGeometry(3.0, 1);
            const shellMat = new THREE.MeshPhongMaterial({
                color: 0x000000,
                wireframe: true,
                transparent: true,
                opacity: 0.6,
                emissive: 0x00fffb,
                emissiveIntensity: 0.3,
                side: THREE.DoubleSide,
                shininess: 100
            });
            outerShell = new THREE.Mesh(shellGeo, shellMat);
            coreGroup.add(outerShell);

            // 3. H·ªá Th·ªëng V√≤ng Xoay (Massive Rings System)
            const ringGeo = new THREE.TorusGeometry(5, 0.05, 2, 100);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, side: THREE.DoubleSide });
            
            const ring1 = new THREE.Mesh(ringGeo, ringMat);
            ring1.rotation.x = Math.PI / 2;
            coreGroup.add(ring1);

            const ring2 = new THREE.Mesh(ringGeo, ringMat);
            ring2.rotation.y = Math.PI / 2;
            coreGroup.add(ring2);

            const ring3 = new THREE.Mesh(ringGeo, ringMat);
            ring3.rotation.z = Math.PI / 2;
            coreGroup.add(ring3);

            // Th√™m hi·ªáu ·ª©ng ph√°t s√°ng (Bloom Effect)
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1;
            bloomPass.strength = 1.2; // ƒê·ªô m·∫°nh c·ªßa √°nh s√°ng h√†o quang
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // X·ª≠ l√Ω thay ƒë·ªïi k√≠ch th∆∞·ªõc c·ª≠a s·ªï
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 2. HI·ªÜU ·ª®NG H·∫†T N·ªÄN (T·∫°o chi·ªÅu s√¢u v≈© tr·ª•) ---
        function initParticles() {
            const canvas = document.getElementById('canvas1');
            const ctx = canvas.getContext('2d');
            let particles = [];
            const particleCount = 500;

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            class Particle {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.z = Math.random() * 5; // ƒê·ªô s√¢u
                    this.size = Math.random() * 1 + 0.5;
                    this.speedX = (Math.random() - 0.5) * 0.1;
                    this.speedY = (Math.random() - 0.5) * 0.1;
                }
                update() {
                    this.x += this.speedX * this.z;
                    this.y += this.speedY * this.z;
                    if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                        this.x = Math.random() * canvas.width;
                        this.y = Math.random() * canvas.height;
                    }
                }
                draw() {
                    ctx.fillStyle = `rgba(0, 255, 251, ${this.z/5})`; // Neon blue glow
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * this.z, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            function init() {
                for (let i = 0; i < particleCount; i++) {
                    particles.push(new Particle());
                }
            }

            function animateParticles() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (let i = 0; i < particles.length; i++) {
                    particles[i].update();
                    particles[i].draw();
                }
                requestAnimationFrame(animateParticles);
            }

            init();
            animateParticles();
        }

        // --- 3. LOGIC MEDIA PIPE V√Ä K·∫æT N·ªêI V·ªöI THREE.JS ---

        const video = document.querySelector('.input_video');
        const canvasElement = document.querySelector('.output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const loadingScreen = document.getElementById('loading');
        
        let targetScale = 1;
        let currentScale = 1;
        let targetRotationY = 0;
        let targetRotationX = 0;

        function animate3D() {
            requestAnimationFrame(animate3D);

            // Chuy·ªÉn ƒë·ªông t·ª± quay nh·∫π nh√†ng
            coreGroup.rotation.y += 0.002;
            innerCore.rotation.x += 0.005;

            // V√≤ng xoay nhanh h∆°n
            coreGroup.children[2].rotation.y += 0.01; // Ring 1
            coreGroup.children[3].rotation.z += 0.015; // Ring 2
            coreGroup.children[4].rotation.x += 0.012; // Ring 3


            // L√†m m·ªãn chuy·ªÉn ƒë·ªông scale
            currentScale += (targetScale - currentScale) * 0.05;
            coreGroup.scale.set(currentScale, currentScale, currentScale);

            // L√†m m·ªãn chuy·ªÉn ƒë·ªông xoay theo tay
            // Gi·ªõi h·∫°n g√≥c xoay ƒë·ªÉ kh√¥ng b·ªã l·ªôn ng∆∞·ª£c
            coreGroup.rotation.y += (targetRotationY - coreGroup.rotation.y) * 0.05;
            coreGroup.rotation.x += (targetRotationX - coreGroup.rotation.x) * 0.05;

            // S·ª≠ d·ª•ng composer ƒë·ªÉ render v·ªõi hi·ªáu ·ª©ng bloom
            composer.render();
        }

        function onResults(results) {
            loadingScreen.style.display = 'none';

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandedness.length > 0) {
                
                const hand = results.multiHandLandmarks[0];
                
                // 1. Logic Scale (Ph√≥ng to/Thu nh·ªè) d·ª±a tr√™n c·ª≠ ch·ªâ tay
                const thumbTip = hand[4];
                const indexTip = hand[8];
                const distance = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

                // Kho·∫£ng c√°ch normalized (0.0 -> 0.5)
                if (distance > 0.1) {
                    targetScale = THREE.MathUtils.clamp(distance * 15, 0.8, 3.0); // TƒÉng d·∫£i scale
                } else {
                    // N·∫øu tay n·∫Øm qu√° ch·∫∑t (c·ª≠ ch·ªâ n·∫Øm tay), thu nh·ªè v·ªÅ m·∫∑c ƒë·ªãnh
                    targetScale = 1.0; 
                }

                // 2. Logic Rotation (Xoay) d·ª±a tr√™n v·ªã tr√≠ tay tr√™n m√†n h√¨nh
                const wrist = hand[0];
                // Map v·ªã tr√≠ X c·ªßa tay (0 ƒë·∫øn 1) sang g√≥c quay Y (-PI/4 ƒë·∫øn PI/4)
                targetRotationY = THREE.MathUtils.mapLinear(wrist.x, 0, 1, Math.PI / 4, -Math.PI / 4);
                // Map v·ªã tr√≠ Y c·ªßa tay (0 ƒë·∫øn 1) sang g√≥c quay X (-PI/6 ƒë·∫øn PI/6)
                targetRotationX = THREE.MathUtils.mapLinear(wrist.y, 0, 1, -Math.PI / 6, Math.PI / 6);


                // V·∫Ω c√°c ƒëi·ªÉm x∆∞∆°ng tay l√™n canvas mini-cam
                drawConnectors(canvasCtx, hand, HAND_CONNECTIONS,
                               {color: '#00ffff', lineWidth: 2});
                drawLandmarks(canvasCtx, hand, {color: '#ff00ff', lineWidth: 1, radius: 3});
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => {
            return `cdn.jsdelivr.net{file}`;
        }});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cameraFeed = new Camera(video, {
            onFrame: async () => {
                await hands.send({image: video});
            },
            width: 1280,
            height: 720
        });
        
        // Kh·ªüi ƒë·ªông c√°c h·ªá th·ªëng
        init3D();
        initParticles();
        animate3D();
        cameraFeed.start();

    </script>

</body>

</html>